# Especificación del editor de base de datos (auditoría del MVP)

## 1. Campos de tarea utilizados en el MVP
- El estado central (`state.rows`) modela cada fila como un arreglo de seis posiciones en orden fijo: `[Pilar, Rasgo, Stat, Task, Dificultad, Feedback]`. Las cinco primeras columnas se guardan y sincronizan con la API; la sexta es un flag local para feedback/acciones de IA.【F:MVP/bbdd.js†L43-L47】【F:MVP/bbdd.js†L210-L218】
- Los valores persistidos se normalizan antes de guardar: `Pilar` se limita a Body/Mind/Soul mediante `normPilar`, `Rasgo` usa `cleanRasgo` para quitar sufijos, `Stat`/`Task` son texto libre, `Dificultad` pasa por `normDiff` y solo acepta Fácil/Media/Difícil. `Feedback` solo admite "improve" o "replace" y no viaja al backend.【F:MVP/bbdd.js†L32-L40】【F:MVP/bbdd.js†L202-L215】【F:MVP/bbdd.js†L248-L282】
- La UI móvil recompone cada `<tr>` en una tarjeta táctil que sigue consumiendo los mismos campos y sincroniza cambios contra `state.rows`, incluida la marca `__aiMode` cuando la IA modifica una task.【F:MVP/index-bbdd.html†L1127-L1207】【F:MVP/index-bbdd.html†L1389-L1417】

## 2. Flujo actual de alta, edición y borrado
1. **Carga inicial** (`init`): obtiene el email desde query/localStorage, configura listeners y llama a `apiGetBBDD`, que trae `rows` (matriz A–E). Se filtran filas sin Task y se extienden con un slot vacío para feedback antes de renderizar.【F:MVP/bbdd.js†L74-L121】【F:MVP/bbdd.js†L486-L532】
2. **Render**: `render()` transforma cada fila en `<tr>` con controles editables, asigna `data-index` y muestra el indicador de cambios pendientes (`state.dirty`). También asocia eventos de input, click y drag & drop.【F:MVP/bbdd.js†L122-L198】
3. **Alta de fila**: el botón `#add-row` inserta `["","","","","",""]` en `state.rows` y repinta. En móvil, el botón duplicado `#add-row-dup` despacha el mismo handler.【F:MVP/bbdd.js†L430-L435】【F:MVP/index-bbdd.html†L1028-L1041】
4. **Edición**: cada control sincroniza su valor con `state.rows` mediante `onRowInput`, que normaliza según la columna, marca el estado como sucio y, si cambia el pilar, fuerza un rerender para recalcular los rasgos. La vista móvil replica esta lógica para dificultad, meta y toggles expandidos.【F:MVP/bbdd.js†L200-L244】【F:MVP/index-bbdd.html†L1227-L1299】
5. **Borrado**: el botón X (desktop) o la acción 🗑️ (móvil) elimina la fila, reindexa `state.aiUpdated` y vuelve a renderizar.【F:MVP/bbdd.js†L246-L268】【F:MVP/index-bbdd.html†L1418-L1440】
6. **Guardado simple** (`doSave`): normaliza filas visibles, valida pilar y task, POSTea a `/bbdd`, reinicia `state.dirty` y el set de IA, y muestra un toast.【F:MVP/bbdd.js†L296-L314】
7. **Confirmación** (`doConfirm`): vuelve a guardar, interpreta la respuesta (`estado`), condiciona el toast y, salvo estado "constante", llama a `/bbdd/confirm` para disparar el flujo de onboarding. También maneja UI de loading y notifica al dashboard/overlay.【F:MVP/bbdd.js†L316-L387】
8. **IA opcional**: selección por feedback (`aiBuildSelection`), envío en lotes a `aiSendBatch`, aplicación de resultados y marca de filas con `state.aiUpdated`. La vista móvil añade accesos directos por fila (`runAiForRow`).【F:MVP/bbdd.js†L356-L446】【F:MVP/index-bbdd.html†L1399-L1435】

## 3. Supuestos de catálogo
- **Pilares**: catálogo fijo `["Body","Mind","Soul"]`. La normalización acepta alias en español/inglés y minúsculas (p. ej. "cuerpo" → Body).【F:MVP/bbdd.js†L8-L36】
- **Rasgos**: diccionario `RASGOS_POR_PILAR` con 10 rasgos por pilar; se usa para poblar `<select>` y validar que un rasgo sea coherente cuando cambia el pilar.【F:MVP/bbdd.js†L10-L18】【F:MVP/bbdd.js†L204-L223】
- **Stats**: texto libre sin catálogo, pero la UI móvil lo trata como metadato editable debajo de la task.【F:MVP/bbdd.js†L139-L150】【F:MVP/index-bbdd.html†L1189-L1222】
- **Dificultad**: catálogo `["Fácil","Media","Difícil"]` con normalización de acentos y alias. El chip móvil cicla entre esos valores y sincroniza el `<select>` oculto.【F:MVP/bbdd.js†L9-L40】【F:MVP/index-bbdd.html†L1245-L1299】
- **Feedback IA**: valores simbólicos "improve"/"replace" almacenados localmente para disparar IA; no se persisten ni viajan a la API.【F:MVP/bbdd.js†L148-L151】【F:MVP/bbdd.js†L356-L401】

## 4. Limitaciones y oportunidades de mejora en UX móvil
- **HTML/CSS redundante**: la hoja de estilos embebida contiene múltiples bloques repetidos y parches secuenciales (varias redefiniciones de `.bbdd-panel`, `header.appbar`, `#bbdd-confirm`), lo que complica mantenimiento y puede generar conflictos al portarlo a componentes modulares.【F:MVP/index-bbdd.html†L62-L456】【F:MVP/index-bbdd.html†L440-L821】
- **Transformaciones DOM manuales**: el script móvil reemplaza cada `<tr>` por tarjetas y gestiona swipe, expansión y sincronización mediante `MutationObserver`, lo que introduce complejidad y riesgo de desincronización en frameworks reactivos. Migrarlo a componentes declarativos permitiría reutilizar lógica y tests.【F:MVP/index-bbdd.html†L1072-L1440】
- **Gestión de gestos personalizada**: `makeSwipeable` implementa a mano thresholds y listeners para arrastre lateral. Al refactorizar se puede delegar en librerías de gestos o APIs pointer modernas para consistencia cross-platform y accesibilidad.【F:MVP/index-bbdd.html†L1324-L1417】
- **Carga cognitiva en confirmación**: se superponen múltiples overlays (spinner de tabla, `aiLoading`, `saving-shield`, botón flotante). Integrar estados en un solo store permitiría mensajes más claros y evitar bloqueo redundante de controles.【F:MVP/bbdd.js†L290-L387】【F:MVP/index-bbdd.html†L1461-L1713】
- **Accesibilidad limitada**: aunque se añade `aria-label` en botones swipe, la reconstrucción dinámica elimina encabezados de tabla y podría dificultar la navegación con lectores de pantalla. Una migración a componentes semánticos (listas con `role` adecuado) puede mejorar soporte asistivo.【F:MVP/index-bbdd.html†L1131-L1216】

## 5. Diferencias previstas al integrarlo con la arquitectura actual
- **Ecosistema**: el MVP es vanilla JS con globals (`window.openBBDD`, `window.doConfirm`, `state`). La app actual es React + TypeScript (Vite) en `apps/web`, por lo que habrá que encapsular la lógica en hooks/contexts o stores (e.g. Zustand) en lugar de mutar `window` y usar `document.querySelector` directo.【F:MVP/bbdd.js†L58-L65】【F:MVP/index-bbdd.html†L1000-L1053】【F:apps/web/src/main.tsx†L1-L39】
- **Gestión de rutas**: hoy la vista depende de parámetros `email`/`back` en la URL y del modo `modal`. En la nueva arquitectura debería integrarse con el enrutador existente y los guardias de autenticación que ya envuelven las rutas (p. ej. `RequireUser`), evitando rely en `localStorage` ad-hoc para sesión.【F:MVP/bbdd.js†L66-L72】【F:MVP/bbdd.js†L404-L455】【F:apps/web/src/App.tsx†L1-L116】
- **Imports y módulos**: funciones como `apiGetBBDD`, normalizadores y utilidades deberán exportarse desde módulos TS, reemplazando el uso global de `fetch` con helpers de cliente ya usados en la app (por ejemplo, `apiRequest` y la configuración del token Clerk). También habrá que mover constantes (`API_BASE`, `PROXY_KEY`) a configuración por entorno para alinearse con las variables `VITE_API_BASE_URL` usadas hoy.【F:MVP/bbdd.js†L4-L25】【F:apps/web/src/lib/api.ts†L1-L120】【F:apps/web/src/lib/api.ts†L199-L346】
- **Estado y efectos**: `render()` manipula el DOM manualmente; en React la representación de filas y tarjetas debe derivar del estado y efectos (`useEffect`) con listas keyeadas. La sincronización de IA y drag & drop debería apoyarse en librerías compatibles o patrones ya presentes (por ejemplo, el modal de Daily Quest usa hooks y refs para coordinación) en vez de listeners nativos globales.【F:MVP/bbdd.js†L122-L198】【F:MVP/index-bbdd.html†L1230-L1440】【F:apps/web/src/components/DailyQuestModal.tsx†L288-L366】
- **Cliente API**: el MVP llama al Worker con headers personalizados (`X-Proxy-Key`) y cookies `include`. Integrarlo requerirá usar el cliente oficial (`apiRequest` + `setApiAuthTokenProvider`) que centraliza base URLs, autenticación Clerk y logging, evitando exponer llaves en el bundle.【F:MVP/bbdd.js†L76-L118】【F:apps/web/src/lib/api.ts†L1-L120】【F:apps/web/src/lib/api.ts†L199-L346】

> Esta especificación documenta el estado actual del MVP para orientar el refactor hacia componentes tipados, reutilizando catálogos globales y los servicios existentes en la aplicación principal.
